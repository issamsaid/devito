import cgen as c
import numpy as np
from cached_property import cached_property
from devito.logger import info
from sympy import Symbol
from collections import Iterable
from devito.exceptions import InvalidArgument

""" This module provides a set of classes that help in processing runtime arguments for
    kernels generated by devito. There are two class hierarchies here:
    - ArgumentProvider: These are for objects that might be used in the expression
      provided to the operator as symbols but might resolve to runtime arguments after
      code generation. Each ArgumentProvider provides one (or more) Argument
      object(s).
    - Argument: Classes inheriting from this are for objects that represent the
      argument itself. Each ArgumentProvider might provide one or more such objects
      which are used as placeholders for the argument as well as for verification and
      derivation of default values.
"""


class Argument(object):

    """ Base class for any object that represents a run time argument for
        generated kernels.
    """

    is_ScalarArgument = False
    is_TensorArgument = False

    def __init__(self, name, provider, default_value=None):
        self.name = name
        self.provider = provider
        self._value = self.default_value = default_value

    def __str__(self):
        return "%s (%s)" % (self.name, str(self.value))
        
    @property
    def value(self):
        return self._value

    @property
    def ready(self):
        return self._value is not None

    @property
    def decl(self):
        raise NotImplemented()

    @property
    def ccode(self):
        return self.name

    def reset(self):
        self._value = self.default_value

    def verify(self, kwargs):
        raise NotImplemented()


class ScalarArgument(Argument):

    """ Class representing scalar arguments that a kernel might expect.
        Most commonly used to pass dimension sizes
    """

    is_ScalarArgument = True

    def __init__(self, name, provider, reducer, default_value=None):
        super(ScalarArgument, self).__init__(name, provider, default_value)
        self.reducer = reducer
        self.frozen = False

    @property
    def decl(self):
        return c.Value('const int', self.name)

    @property
    def dtype(self):
        return np.int32

    def verify(self, value, enforce=False):

        if value is not None:
            assert(value is not None or not enforce)
            if self.value is None:
                self._value = value
            else:
                if enforce:
                    self._value = value
                    self.frozen = True
                else:
                    if not self.frozen:
                        self._value = self.reducer(self._value, value)
        return self._value is not None


class TensorArgument(Argument):

    """ Class representing tensor arguments that a kernel might expect.
        Most commonly used to pass numpy-like multi-dimensional arrays.
    """

    is_TensorArgument = True

    def __init__(self, name, provider, dtype):
        super(TensorArgument, self).__init__(name, provider)
        self.dtype = dtype
        self._value = self.default_value = self.provider

    @property
    def value(self):
        if isinstance(self._value, np.ndarray):
            return self._value
        else:
            return self._value.data

    @property
    def decl(self):
        return c.Value(c.dtype_to_ctype(self.dtype), '*restrict %s_vec' % self.name)

    @property
    def ccast(self):
        alignment = "__attribute__((aligned(64)))"
        shape = ''.join(["[%s]" % i.size for i in self.provider.indices[1:]])

        cast = c.Initializer(c.POD(self.dtype,
                                   '(*restrict %s)%s %s' % (self.name, shape, alignment)),
                             '(%s (*)%s) %s' % (c.dtype_to_ctype(self.dtype),
                                                shape, '%s_vec' % self.name))
        return cast

    def verify(self, value):
        if value is None:
            value = self._value

        verify = self.provider.shape == value.shape

        verify = verify and all(d.verify(v) for d, v in zip(self.provider.indices,
                                                            value.shape))
        if verify:
            self._value = value

        return self._value is not None and verify


class ArgumentProvider(object):

    """ Abstract base class for any object that, post code-generation, might resolve
        resolve to runtime arguments. We assume that one source object (e.g. Dimension,
        SymbolicData) might provide multiple runtime arguments.
    """

    def __init__(self, *args, **kwargs):
        pass

    @property
    def rtargs(self):
        """ Return a list of RuntimeArgument objects that this object needs.
        """
        raise NotImplemented()


class FixedDimensionArgProvider(ArgumentProvider):

    @property
    def value(self):
        return self.size

    def reset(self):
        pass

    @property
    def dtype(self):
        """The data type of the iteration variable"""
        return np.int32

    @cached_property
    def rtargs(self):
        return []

    @property
    def ccode(self):
        return "%d" % self.size

    @property
    def decl(self):
        raise NotImplemented()

    def verify(self, value):
        if isinstance(value, tuple) and value[0] == 0:
            _, value = value

        if value is None:
            return True
        return (value >= self.size)

    @property
    def limits(self):
        return (0, self.size, 1)


class DimensionArgProvider(ArgumentProvider):

    """ This class is used to decorate the Dimension class with behaviour required
        to handle runtime arguments. All properties/methods defined here are available
        in any Dimension object.
    """

    reducer = max
    _default_value = None

    def __init__(self, *args, **kwargs):
        super(DimensionArgProvider, self).__init__(*args, **kwargs)
        self.reset()

    def reset(self):
        for i in self.rtargs:
            i.reset()

    @property
    def value(self):
        child_values = tuple([i.value for i in self.rtargs])
        return child_values if all(i is not None for i in child_values) else None

    @cached_property
    def rtargs(self):
        start = ScalarArgument("%s_s" % self.name, self, max, 0)
        end = ScalarArgument("%s_e" % self.name, self, max)
        return [start, end]

    @property
    def ccode(self):
        """C-level variable name of this dimension"""
        # If we have start and end variables, the "size" of the dimension is now:
        start, end = self.rtargs
        raise NotImplemented()
        return "%s - %s" % (end.ccode, start.ccode)
    

    @property
    def limits(self):
        start, end = self.rtargs
        return (Symbol(start.ccode), Symbol(end.ccode), 1)

    def promote(self, value):
        if not (isinstance(value, tuple) and len(value)==2):
            if isinstance(value, Iterable):
                raise InvalidArgument("Expected either a single value or a tuple(2)")
            start, _ = self.rtargs
            value = (start.default_value, value)
        return value

    # TODO: Can we do without a verify on a dimension?
    def verify(self, value, enforce=False):
        verify = True
    
        if value is None:
            if self.value is not None:
                return True
            
            # If I don't know my value, ask my parent
            try:
                value = self.parent.value
                if value is None: # Still
                    return False
            except AttributeError:
                return False

        if value == self.value:
            return True

        value = self.promote(value)

        try:
            parent_val = self.parent.value
            if parent_val is not None and not enforce:
                parent_val = self.promote(parent_val)
                value = tuple([self.reducer(i1, i2) for i1, i2 in zip(value, parent_val)])
            verify = verify and self.parent.verify(value, enforce=enforce)
        except AttributeError:
            pass
        
        # Derived dimensions could be linked through constraints
        # At this point, a constraint needs to be added that enforces
        # dim_e - dim_s < SOME_MAX
        # Also need a default constraint that dim_e > dim_s (or vice-versa)
        verify = verify and all([a.verify(v, enforce) for a, v in zip(self.rtargs, value)])

        return verify

class SymbolicDataArgProvider(ArgumentProvider):
    """ Class used to decorate Symbolic Data objects with behaviour required for runtime
        arguments.
    """

    @cached_property
    def rtargs(self):
        return [TensorArgument(self.name, self, self.dtype)]


class ScalarFunctionArgProvider(ArgumentProvider):

    """ Class used to decorate Scalar Function objects with behaviour required for runtime
        arguments.
    """

    @cached_property
    def rtargs(self):
        return [ScalarArgument(self.name, self, self.dtype)]


class TensorFunctionArgProvider(ArgumentProvider):

    """ Class used to decorate Tensor Function objects with behaviour required for runtime
        arguments.
    """

    @cached_property
    def rtargs(self):
        return [TensorArgument(self.name, self, self.dtype)]


def log_args(arguments):
    arg_str = []
    for k, v in arguments.items():
        if hasattr(v, 'shape'):
            try:
                arg_str.append('(%s, shape=%s, L2 Norm=%d)' %
                                   (k, str(v.shape), np.linalg.norm(v)))
            except Exception as e:
                raise InvalidArgument("Unable to calculate L2 norm of %s: %s" % (k, str(e)))
        else:
            arg_str.append('(%s, value=%s)' % (k, str(v)))
    info("Passing Arguments: " + ", ".join(arg_str))
